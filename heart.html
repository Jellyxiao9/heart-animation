<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>粒子爱心</title>
    <style>
        body { margin: 0; background: #0a0a1a; overflow: hidden; }
        canvas { display: block; }
        .tip { position: fixed; bottom: 20px; width: 100%; color: rgba(255,255,255,0.6); text-align: center; font-size: 14px; pointer-events: none; }
    </style>
</head>
<body>
    <div class="tip">点击屏幕互动</div>
    <script>
        // 获取画布并设置尺寸
        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        const ctx = canvas.getContext('2d');
        
        // 适配手机屏幕
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const width = window.innerWidth;
            const height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
            ctx.scale(dpr, dpr);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // 粒子类
        class Particle {
            constructor() {
                this.reset();
            }
            
            // 重置粒子状态
            reset() {
                const centerX = canvas.width / 2 / (window.devicePixelRatio || 1);
                const centerY = canvas.height / 2 / (window.devicePixelRatio || 1);
                
                // 随机初始位置
                this.x = Math.random() * canvas.width / (window.devicePixelRatio || 1);
                this.y = Math.random() * canvas.height / (window.devicePixelRatio || 1);
                
                // 目标位置（爱心形状）
                this.targetX = 0;
                this.targetY = 0;
                this.calculateTarget(centerX, centerY);
                
                // 粒子属性
                this.size = Math.random() * 2 + 1;
                this.speed = Math.random() * 0.8 + 0.2;
                this.color = this.getRandomColor();
                this.originalTargetX = this.targetX;
                this.originalTargetY = this.targetY;
                this.isSpecial = Math.random() < 0.05; // 特殊亮粒子
            }
            
            // 计算爱心形状的目标位置（基于心形曲线）
            calculateTarget(centerX, centerY) {
                const t = Math.random() * Math.PI * 2;
                const size = Math.min(canvas.width, canvas.height) * 0.3;
                
                // 心形曲线参数方程
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                
                // 随机偏移使爱心更自然
                const offset = (Math.random() - 0.5) * 20;
                this.targetX = centerX + x * (size / 16) + offset;
                this.targetY = centerY - y * (size / 16) + offset; // 负号是因为canvas y轴向下
            }
            
            // 获取随机粉色系颜色
            getRandomColor() {
                const r = 255;
                const g = Math.floor(Math.random() * 80) + 30;
                const b = Math.floor(Math.random() * 120) + 50;
                const a = Math.random() * 0.8 + 0.2;
                return `rgba(${r}, ${g}, ${b}, ${a})`;
            }
            
            // 更新粒子位置
            update(mouseX, mouseY) {
                // 鼠标互动：粒子受鼠标吸引
                let dx = this.targetX - this.x;
                let dy = this.targetY - this.y;
                
                // 如果有鼠标位置，添加吸引力
                if (mouseX !== null && mouseY !== null) {
                    const mouseDist = Math.hypot(mouseX - this.x, mouseY - this.y);
                    if (mouseDist < 100) {
                        dx = mouseX - this.x;
                        dy = mouseY - this.y;
                    }
                }
                
                // 移动到目标位置
                const dist = Math.hypot(dx, dy);
                if (dist > 0) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
            }
            
            // 绘制粒子
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * (this.isSpecial ? 1.5 : 1), 0, Math.PI * 2);
                ctx.fill();
                
                // 特殊粒子添加光晕
                if (this.isSpecial) {
                    ctx.fillStyle = `rgba(255, 255, 255, 0.3)`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // 创建粒子群
        const particles = [];
        const particleCount = Math.floor(window.innerWidth * 0.8); // 根据屏幕宽度调整粒子数量
        
        for (let i = 0; i < particleCount; i++) {
            particles.push(new Particle());
        }
        
        // 鼠标/触摸位置
        let mouseX = null;
        let mouseY = null;
        
        // 触摸事件
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            mouseX = touch.clientX;
            mouseY = touch.clientY;
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            mouseX = touch.clientX;
            mouseY = touch.clientY;
        });
        
        canvas.addEventListener('touchend', () => {
            mouseX = null;
            mouseY = null;
        });
        
        // 鼠标事件（适配电脑）
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        canvas.addEventListener('mouseleave', () => {
            mouseX = null;
            mouseY = null;
        });
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 清空画布
            ctx.clearRect(0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
            
            // 更新并绘制所有粒子
            particles.forEach(particle => {
                particle.update(mouseX, mouseY);
                particle.draw();
            });
        }
        
        // 启动动画
        animate();
    </script>
</body>
</html>